#!/usr/bin/perl

use strict;
use warnings;

use Getopt::Long;
use List::Util qw(min max);

my $invert_x;
my $invert_y;
my $show_bounds;

GetOptions(
    'invert-x' => \$invert_x,
    'invert-y' => \$invert_y,
    'show-bounds' => \$show_bounds,
) or usage();

my ($curx, $cury, $curz);
my ($minx, $miny, $minz);
my ($maxx, $maxy, $maxz);

my $gcodefile = shift;
@ARGV == 0 or usage();

my $gcode = slurp($gcodefile);

while (<>) {
    chomp;

    my ($x, $y, $z) = split /\s/;

    $z //= 0;

    print "(gcodetile: offset $x,$y,$z)\n";
    print offset_gcode($gcode, $x, $y, $z);
}

if ($show_bounds) {
    print STDERR sprintf("X bounds: %.5f .. %.5f\n", $minx, $maxx);
    print STDERR sprintf("Y bounds: %.5f .. %.5f\n", $miny, $maxy);
    print STDERR sprintf("Z bounds: %.5f .. %.5f\n", $minz, $maxz);
}

sub offset_gcode {
    my ($gcode, $x, $y, $z) = @_;

    my $relative = 0;

    my @lines = split /\n/, $gcode;
    for my $l (@lines) {
        if ($l =~ /^\s*\(/) { # leave comments alone
            print $l;
        } else { # process g-code
            while ($l =~ /([A-Z])([0-9.-]+)(\s*)/gi) {
                my ($letter, $arg, $space) = ($1, $2, $3);
                $letter = uc $letter;
                $relative = 0 if $letter eq 'G' && $arg == 90;
                $relative = 1 if $letter eq 'G' && $arg == 91;

                warn "warning: can't invert circular motion!\n" if $letter eq 'G' && ($arg == 2 || $arg == 3) && ($invert_x || $invert_y);

                $arg = -$arg if $invert_x && $letter eq 'X';
                $arg = -$arg if $invert_y && $letter eq 'Y';

                $arg += $x if !$relative && $letter eq 'X';
                $arg += $y if !$relative && $letter eq 'Y';
                $arg += $z if !$relative && $letter eq 'Z';

                if ($letter eq 'M' && $arg == 2) {
                    warn "note: removing M2 (Program End)\n";
                    next;
                }

                print "$letter$arg$space";

                if ($relative) {
                    $curx += $arg if $letter eq 'X';
                    $cury += $arg if $letter eq 'Y';
                    $curz += $arg if $letter eq 'Z';
                } else {
                    $curx = $arg if $letter eq 'X';
                    $cury = $arg if $letter eq 'Y';
                    $curz = $arg if $letter eq 'Z';
                }

                $minx = $curx if !defined $minx;
                $maxx = $curx if !defined $maxx;
                $miny = $cury if !defined $miny;
                $maxy = $cury if !defined $maxy;
                $minz = $curz if !defined $minz;
                $maxz = $curz if !defined $maxz;
                $minx = min($minx, $curx) if defined $minx;
                $maxx = max($maxx, $curx) if defined $maxx;
                $miny = min($miny, $cury) if defined $miny;
                $maxy = max($maxy, $cury) if defined $maxy;
                $minz = min($minz, $curz) if defined $minz;
                $maxz = max($maxz, $curz) if defined $maxz;
            }
            # TODO: print rest of $l from pos($l) to end, if any?
        }
        print "\n";
    }
}

sub usage {
    print qq{usage: gcodetile [options] GCODEFILE < OFFSETS

Options:
  --invert-x     Invert X coordinates from GCODEFILE
  --invert-y     Invert Y coordinates from GCODEFILE
  --show-bounds  Show bounds of output coordinates on STDERR

Give OFFSETS on stdin in the form "X Y" or "X Y Z", one per line, ending
at EOF, for example:

\$ gcodetile part.gcode
0 0
0 10
0 20
10 0
10 10
10 20
^D

gcodetile is created by James Stanley. You can email me on james\@incoherency.co.uk
or read my blog at https://incoherency.co.uk/
};
    exit 0;
}

sub slurp {
    my ($file) = @_;

    open (my $fh, '<', $file)
        or die "can't read $file: $!\n";
    my $c = join('', <$fh>);
    close $fh;

    return $c;
}
